################################################################################
# This file was automatically generated by h3_generate_E_L.py
################################################################################
import numpy as np


def calculate_M(x, m_1, m_2, m_3, J1_x, J1_y, J1_z, J2_x, J2_y, J2_z, J3_x, J3_y, J3_z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    M = np.array([[J1_x, 0, -J1_x*np.sin(theta)], [0, -J1_y*np.sin(phi)**2 + J1_y + J1_z*np.sin(phi)**2 + J2_y + ell_1**2*m_1 + ell_2**2*m_2, (J1_y - J1_z)*np.sin(phi)*np.cos(phi)*np.cos(theta)], [-J1_x*np.sin(theta), (J1_y - J1_z)*np.sin(phi)*np.cos(phi)*np.cos(theta), -J1_x*np.cos(theta)**2 + J1_x - J1_y*np.cos(phi)**2*np.cos(theta)**2 + J1_y*np.cos(theta)**2 + J1_z*np.cos(phi)**2*np.cos(theta)**2 - J2_x*np.cos(theta)**2 + J2_x + J2_z*np.cos(theta)**2 + J3_z + ell_1**2*m_1*np.cos(theta)**2 + ell_2**2*m_2*np.cos(theta)**2 + ell_3x**2*m_3 + ell_3y**2*m_3]])
    return M


def calculate_C(x, m_1, m_2, m_3, J1_x, J1_y, J1_z, J2_x, J2_y, J2_z, J3_x, J3_y, J3_z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    C = np.array([[-J1_x*psidot*thetadot*np.cos(theta) - psidot*(psidot*(J1_y - J1_z)*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 + (1/2)*thetadot*(J1_y - J1_z)*np.cos(2*phi)*np.cos(theta)) - thetadot*((1/2)*psidot*(J1_y - J1_z)*np.cos(2*phi)*np.cos(theta) + (1/2)*thetadot*(-J1_y + J1_z)*np.sin(2*phi))], [(1/2)*J1_x*phidot*psidot*np.cos(theta) + (1/2)*psidot*thetadot*(J1_y - J1_z)*np.sin(phi)*np.sin(theta)*np.cos(phi) - psidot*(-1/2*J1_x*phidot*np.cos(theta) + (1/2)*psidot*(2*J1_x*np.sin(theta)*np.cos(theta) + 2*J1_y*np.sin(theta)*np.cos(phi)**2*np.cos(theta) - 2*J1_y*np.sin(theta)*np.cos(theta) - 2*J1_z*np.sin(theta)*np.cos(phi)**2*np.cos(theta) + 2*J2_x*np.sin(theta)*np.cos(theta) - 2*J2_z*np.sin(theta)*np.cos(theta) - 2*ell_1**2*m_1*np.sin(theta)*np.cos(theta) - 2*ell_2**2*m_2*np.sin(theta)*np.cos(theta)) - 1/2*thetadot*(J1_y - J1_z)*np.sin(phi)*np.sin(theta)*np.cos(phi)) + psidot*(-phidot*(J1_y - J1_z)*np.sin(phi)**2*np.cos(theta) + phidot*(J1_y - J1_z)*np.cos(phi)**2*np.cos(theta) - thetadot*(J1_y - J1_z)*np.sin(phi)*np.sin(theta)*np.cos(phi)) + thetadot*(-2*J1_y*phidot*np.sin(phi)*np.cos(phi) + 2*J1_z*phidot*np.sin(phi)*np.cos(phi))], [-J1_x*phidot*thetadot*np.cos(theta) + psidot*(2*J1_x*thetadot*np.sin(theta)*np.cos(theta) + 2*J1_y*phidot*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 + 2*J1_y*thetadot*np.sin(theta)*np.cos(phi)**2*np.cos(theta) - 2*J1_y*thetadot*np.sin(theta)*np.cos(theta) - 2*J1_z*phidot*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 - 2*J1_z*thetadot*np.sin(theta)*np.cos(phi)**2*np.cos(theta) + 2*J2_x*thetadot*np.sin(theta)*np.cos(theta) - 2*J2_z*thetadot*np.sin(theta)*np.cos(theta) - 2*ell_1**2*m_1*thetadot*np.sin(theta)*np.cos(theta) - 2*ell_2**2*m_2*thetadot*np.sin(theta)*np.cos(theta)) + thetadot*(-phidot*(J1_y - J1_z)*np.sin(phi)**2*np.cos(theta) + phidot*(J1_y - J1_z)*np.cos(phi)**2*np.cos(theta) - thetadot*(J1_y - J1_z)*np.sin(phi)*np.sin(theta)*np.cos(phi))]])
    return C


def calculate_dP_dq(x, m_1, m_2, m_3, J1_x, J1_y, J1_z, J2_x, J2_y, J2_z, J3_x, J3_y, J3_z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    dP_dq = np.array([[0], [ell_1*g*m_1*np.cos(theta) + ell_2*g*m_2*np.cos(theta)], [0]])
    return dP_dq


def calculate_tau(x, u, m_1, m_2, m_3, J1_x, J1_y, J1_z, J2_x, J2_y, J2_z, J3_x, J3_y, J3_z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    [f_l, f_r] = np.ravel(u)  # make 1D
    tau = np.array([[d*(f_l - f_r)], [ell_T*(f_l + f_r)*np.cos(phi)], [-d*(f_l - f_r)*np.sin(theta) + ell_T*(f_l + f_r)*np.sin(phi)*np.cos(theta)]])
    return tau
