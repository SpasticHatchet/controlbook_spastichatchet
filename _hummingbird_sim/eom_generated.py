################################################################################
# This file was automatically generated by h3_generate_E_L.py
################################################################################
import numpy as np


def calculate_M(x, m_1, m_2, m_3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    M = np.array([[J_1x, 0, -J_1x*np.sin(theta)], [0, -J_1y*np.sin(phi)**2 + J_1y + J_1z*np.sin(phi)**2 + J_2y + ell_1**2*m_1 + ell_2**2*m_2, (J_1y - J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta)], [-J_1x*np.sin(theta), (J_1y - J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta), -J_1x*np.cos(theta)**2 + J_1x - J_1y*np.cos(phi)**2*np.cos(theta)**2 + J_1y*np.cos(theta)**2 + J_1z*np.cos(phi)**2*np.cos(theta)**2 - J_2x*np.cos(theta)**2 + J_2x + J_2z*np.cos(theta)**2 + J_3z + ell_1**2*m_1*np.cos(theta)**2 + ell_2**2*m_2*np.cos(theta)**2 + ell_3x**2*m_3 + ell_3y**2*m_3]])
    return M


def calculate_C(x, m_1, m_2, m_3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    C = np.array([[-J_1x*psidot*thetadot*np.cos(theta) - psidot*(psidot*(J_1y - J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 + (1/2)*thetadot*(J_1y - J_1z)*np.cos(2*phi)*np.cos(theta)) - thetadot*((1/2)*psidot*(J_1y - J_1z)*np.cos(2*phi)*np.cos(theta) + (1/2)*thetadot*(-J_1y + J_1z)*np.sin(2*phi))], [(1/2)*J_1x*phidot*psidot*np.cos(theta) + (1/2)*psidot*thetadot*(J_1y - J_1z)*np.sin(phi)*np.sin(theta)*np.cos(phi) - psidot*(-1/2*J_1x*phidot*np.cos(theta) + (1/2)*psidot*(2*J_1x*np.sin(theta)*np.cos(theta) + 2*J_1y*np.sin(theta)*np.cos(phi)**2*np.cos(theta) - 2*J_1y*np.sin(theta)*np.cos(theta) - 2*J_1z*np.sin(theta)*np.cos(phi)**2*np.cos(theta) + 2*J_2x*np.sin(theta)*np.cos(theta) - 2*J_2z*np.sin(theta)*np.cos(theta) - 2*ell_1**2*m_1*np.sin(theta)*np.cos(theta) - 2*ell_2**2*m_2*np.sin(theta)*np.cos(theta)) - 1/2*thetadot*(J_1y - J_1z)*np.sin(phi)*np.sin(theta)*np.cos(phi)) + psidot*(-phidot*(J_1y - J_1z)*np.sin(phi)**2*np.cos(theta) + phidot*(J_1y - J_1z)*np.cos(phi)**2*np.cos(theta) - thetadot*(J_1y - J_1z)*np.sin(phi)*np.sin(theta)*np.cos(phi)) + thetadot*(-2*J_1y*phidot*np.sin(phi)*np.cos(phi) + 2*J_1z*phidot*np.sin(phi)*np.cos(phi))], [-J_1x*phidot*thetadot*np.cos(theta) + psidot*(2*J_1x*thetadot*np.sin(theta)*np.cos(theta) + 2*J_1y*phidot*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 + 2*J_1y*thetadot*np.sin(theta)*np.cos(phi)**2*np.cos(theta) - 2*J_1y*thetadot*np.sin(theta)*np.cos(theta) - 2*J_1z*phidot*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 - 2*J_1z*thetadot*np.sin(theta)*np.cos(phi)**2*np.cos(theta) + 2*J_2x*thetadot*np.sin(theta)*np.cos(theta) - 2*J_2z*thetadot*np.sin(theta)*np.cos(theta) - 2*ell_1**2*m_1*thetadot*np.sin(theta)*np.cos(theta) - 2*ell_2**2*m_2*thetadot*np.sin(theta)*np.cos(theta)) + thetadot*(-phidot*(J_1y - J_1z)*np.sin(phi)**2*np.cos(theta) + phidot*(J_1y - J_1z)*np.cos(phi)**2*np.cos(theta) - thetadot*(J_1y - J_1z)*np.sin(phi)*np.sin(theta)*np.cos(phi))]])
    return C


def calculate_dP_dq(x, m_1, m_2, m_3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    dP_dq = np.array([[0], [ell_1*g*m_1*np.cos(theta) + ell_2*g*m_2*np.cos(theta)], [0]])
    return dP_dq


def calculate_tau(x, u, m_1, m_2, m_3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = np.ravel(x)  # make 1D
    [f_l, f_r] = np.ravel(u)  # make 1D
    tau = np.array([[d*(f_l - f_r)], [ell_T*(f_l + f_r)*np.cos(phi)], [-d*(f_l - f_r)*np.sin(theta) + ell_T*(f_l + f_r)*np.sin(phi)*np.cos(theta)]])
    return tau
